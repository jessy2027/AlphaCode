/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { Emitter, Event } from "../../../../base/common/event.js";
import { Disposable } from "../../../../base/common/lifecycle.js";
import { generateUuid } from "../../../../base/common/uuid.js";
import { VSBuffer } from "../../../../base/common/buffer.js";
import { localize } from "../../../../nls.js";
import {
	IStorageService,
	StorageScope,
	StorageTarget,
} from "../../../../platform/storage/common/storage.js";
import { IAlphaCodeAIService } from "../common/aiService.js";
import { IChatEditingService } from "../../chat/common/chatEditingService.js";
import type { IAIMessage } from "../common/aiProvider.js";
import type {
	IAlphaCodeChatService,
	IChatContext,
	IChatMessage,
	IChatSession,
	IStreamChunk,
	IChatTool,
	IToolCall,
	IToolResult,
} from "../common/chatService.js";
import {
	IAlphaCodeContextService,
} from "../common/contextService.js";
import type { IFileContext } from "../common/contextService.js";
import { IAlphaCodeSecurityService } from "../common/securityService.js";
import { ChatToolsRegistry } from "./chatTools.js";
import type { IToolEditProposal } from "./chatTools.js";
import { IFileService } from "../../../../platform/files/common/files.js";
import { IWorkspaceContextService } from "../../../../platform/workspace/common/workspace.js";
import { IEditorService } from "../../../../workbench/services/editor/common/editorService.js";
import type { IResourceDiffEditorInput } from "../../../../workbench/common/editor.js";
import { URI } from "../../../../base/common/uri.js";

const STORAGE_KEY_SESSIONS = "alphacode.chat.sessions";
const STORAGE_KEY_CURRENT_SESSION = "alphacode.chat.currentSession";
const MAX_WORKSPACE_FILE_REFERENCES = 20;
const MAX_WORKSPACE_SYMBOLS = 100;
const MAX_WORKSPACE_SNIPPETS = 6;
const MAX_SNIPPET_LENGTH = 2000;
const STORAGE_KEY_TOOL_DECISIONS = "alphacode.chat.tool.decisions";

interface IToolEditDecisionRecord {
	id: string;
	path: string;
	action: "accepted" | "rejected";
	timestamp: number;
}

export class AlphaCodeChatService
	extends Disposable
	implements IAlphaCodeChatService
{
	declare readonly _serviceBrand: undefined;

	private readonly _onDidAddMessage = this._register(
		new Emitter<IChatMessage>(),
	);
	readonly onDidAddMessage: Event<IChatMessage> = this._onDidAddMessage.event;

	private readonly _onDidCreateSession = this._register(
		new Emitter<IChatSession>(),
	);
	readonly onDidCreateSession: Event<IChatSession> =
		this._onDidCreateSession.event;

	private readonly _onDidStreamChunk = this._register(
		new Emitter<IStreamChunk>(),
	);
	readonly onDidStreamChunk: Event<IStreamChunk> = this._onDidStreamChunk.event;

	private sessions: Map<string, IChatSession> = new Map();
	private currentSessionId: string | undefined;
	private toolsRegistry: ChatToolsRegistry;
	private pendingProposals: Map<string, IToolEditProposal & { id: string }> = new Map();
	private readonly proposalTools: IChatTool[];
	private auditLog: IToolEditDecisionRecord[] = [];
	private proposalSequence = 0;

	constructor(
		@IAlphaCodeAIService private readonly aiService: IAlphaCodeAIService,
		@IStorageService private readonly storageService: IStorageService,
		@IAlphaCodeSecurityService
		private readonly securityService: IAlphaCodeSecurityService,
		@IAlphaCodeContextService
		private readonly contextService: IAlphaCodeContextService,
		@IFileService private readonly fileService: IFileService,
		@IWorkspaceContextService workspaceContextService: IWorkspaceContextService,
		@IEditorService private readonly editorService: IEditorService,
		@IChatEditingService private readonly chatEditingService: IChatEditingService,
	) {
		super();
		this.loadDecisionLog();
		this.toolsRegistry = new ChatToolsRegistry(
			fileService,
			workspaceContextService,
			this.handleToolEditProposal.bind(this),
		);
		this.proposalTools = [
			{
				name: "accept_edit_proposal",
				description:
					"Accept a pending edit proposal previously generated by a tool.",
				parameters: {
					type: "object",
					properties: {
						id: {
							type: "string",
							description: "The proposal identifier returned when the diff was created.",
						},
					},
					required: ["id"],
				},
				execute: async (params: { id: string }) =>
					await this.acceptEditProposal(params.id),
			},
			{
				name: "reject_edit_proposal",
				description:
					"Reject and discard a pending edit proposal without applying changes.",
				parameters: {
					type: "object",
					properties: {
						id: {
							type: "string",
							description: "The proposal identifier returned when the diff was created.",
						},
					},
					required: ["id"],
				},
				execute: async (params: { id: string }) =>
					await this.rejectEditProposal(params.id),
			},
			{
				name: "list_edit_proposals",
				description:
					"List all pending edit proposals awaiting approval.",
				parameters: {
					type: "object",
					properties: {},
				},
				execute: async () => this.listEditProposals(),
			},
		];
		this.loadSessions();
	}

	private appendSystemMessage(content: string): void {
		const session = this.getCurrentSession();
		if (!session) {
			return;
		}
		const message: IChatMessage = {
			id: generateUuid(),
			role: "system",
			content,
			timestamp: Date.now(),
		};
		session.messages.push(message);
		session.updated = Date.now();
		this._onDidAddMessage.fire(message);
		this.saveSessions();
	}

	private loadSessions(): void {
		const stored = this.storageService.get(
			STORAGE_KEY_SESSIONS,
			StorageScope.WORKSPACE,
		);
		if (stored) {
			try {
				const sessions: IChatSession[] = JSON.parse(stored);
				sessions.forEach((session) => this.sessions.set(session.id, session));
			} catch (error) {
				console.error("Failed to parse chat sessions", error);
			}
		}

		const currentId = this.storageService.get(
			STORAGE_KEY_CURRENT_SESSION,
			StorageScope.WORKSPACE,
		);
		if (currentId && this.sessions.has(currentId)) {
			this.currentSessionId = currentId;
		}

		// Create default session if none exist
		if (this.sessions.size === 0) {
			this.createSession();
		}
	}

	private saveSessions(): void {
		const sessionsArray = Array.from(this.sessions.values());
		this.storageService.store(
			STORAGE_KEY_SESSIONS,
			JSON.stringify(sessionsArray),
			StorageScope.WORKSPACE,
			StorageTarget.MACHINE,
		);

		if (this.currentSessionId) {
			this.storageService.store(
				STORAGE_KEY_CURRENT_SESSION,
				this.currentSessionId,
				StorageScope.WORKSPACE,
				StorageTarget.MACHINE,
			);
		}
	}

	getCurrentSession(): IChatSession | undefined {
		if (!this.currentSessionId) {
			return undefined;
		}
		return this.sessions.get(this.currentSessionId);
	}

	createSession(title?: string): IChatSession {
		const session: IChatSession = {
			id: generateUuid(),
			title: title || `Session ${this.sessions.size + 1}`,
			messages: [],
			created: Date.now(),
			updated: Date.now(),
		};

		this.sessions.set(session.id, session);
		this.currentSessionId = session.id;
		this.saveSessions();
		this._onDidCreateSession.fire(session);

		return session;
	}

	switchSession(sessionId: string): void {
		if (this.sessions.has(sessionId)) {
			this.currentSessionId = sessionId;
			this.saveSessions();
		}
	}

	async sendMessage(content: string, context?: IChatContext): Promise<void> {
		const session = this.getCurrentSession();
		if (!session) {
			throw new Error("No active chat session");
		}

		// Add user message
		const userMessage: IChatMessage = {
			id: generateUuid(),
			role: "user",
			content,
			timestamp: Date.now(),
		};

		session.messages.push(userMessage);
		session.updated = Date.now();
		this._onDidAddMessage.fire(userMessage);
		this.saveSessions();

		// Build context-aware messages
		let enrichedContext = context;
		const workspaceContext = await this.contextService.getWorkspaceContext();
		const relevantFiles = await this.getRelevantFiles(
			content,
			workspaceContext.files,
		);
		const workspaceFiles = relevantFiles.map((file) => file.path);
		const workspaceSnippets = relevantFiles
			.slice(0, MAX_WORKSPACE_SNIPPETS)
			.map((file) => this.createSnippetForFile(file));
		const symbolEntries = workspaceContext.symbols
			.slice(0, MAX_WORKSPACE_SYMBOLS)
			.map(
				(symbol) =>
					`${symbol.kind}: ${symbol.name} (${symbol.location.uri.path})`,
			);
		if (
			!enrichedContext ||
			enrichedContext.workspaceFiles === undefined ||
			enrichedContext.symbols === undefined ||
			enrichedContext.workspaceSnippets === undefined
		) {
			enrichedContext = {
				...context,
				workspaceFiles,
				symbols: symbolEntries,
				workspaceSnippets: workspaceSnippets.filter(Boolean) as string[],
			};
		} else {
			enrichedContext.workspaceFiles =
				enrichedContext.workspaceFiles ?? workspaceFiles;
			enrichedContext.symbols = enrichedContext.symbols ?? symbolEntries;
			enrichedContext.workspaceSnippets =
				enrichedContext.workspaceSnippets ??
				(workspaceSnippets.filter(Boolean) as string[]);
		}

		const aiMessages: IAIMessage[] = this.buildAIMessages(
			session,
			enrichedContext,
		);

		try {
			const messageId = generateUuid();
			let fullContent = "";
			let assistantMessage: IChatMessage | undefined;
			const detectedToolCalls = new Map<string, IToolCall>();
			const toolExecutionPromises: Promise<void>[] = [];
			const toolExtractionState = { lastIndex: 0 };

			await this.aiService.sendMessageStream(aiMessages, async (chunk) => {
				if (!chunk.done) {
					fullContent += chunk.content;
					if (!assistantMessage && fullContent.trim().length > 0) {
						assistantMessage = {
							id: messageId,
							role: "assistant",
							content: fullContent,
							timestamp: Date.now(),
						};
						session.messages.push(assistantMessage);
						session.updated = Date.now();
						this._onDidAddMessage.fire(assistantMessage);
						this.saveSessions();
						await this._ensureChatEditingView();
					} else if (assistantMessage) {
						assistantMessage.content = fullContent;
						assistantMessage.timestamp = Date.now();
					}

					this._onDidStreamChunk.fire({
						content: chunk.content,
						done: false,
						messageId,
					});

					const toolCallsInContent = this.extractToolCalls(
						fullContent,
						toolExtractionState,
					);
					for (const toolCall of toolCallsInContent) {
						const key = this.getToolCallKey(toolCall);
						if (!detectedToolCalls.has(key)) {
							detectedToolCalls.set(key, toolCall);
							toolExecutionPromises.push(
								this.executeToolCallDuringStreaming(session, toolCall),
							);
						}
					}
				} else {
					this._onDidStreamChunk.fire({ content: "", done: true, messageId });
				}
			});

			if (!assistantMessage && fullContent.trim().length > 0) {
				assistantMessage = {
					id: messageId,
					role: "assistant",
					content: fullContent,
					timestamp: Date.now(),
				};
				session.messages.push(assistantMessage);
				session.updated = Date.now();
				this._onDidAddMessage.fire(assistantMessage);
				await this._ensureChatEditingView();
			}

			if (assistantMessage) {
				assistantMessage.content = fullContent;
				assistantMessage.timestamp = Date.now();
				if (detectedToolCalls.size > 0) {
					assistantMessage.toolCalls = Array.from(
						detectedToolCalls.values(),
					);
				} else {
					delete assistantMessage.toolCalls;
				}
			}

			this.saveSessions();

			await Promise.all(toolExecutionPromises);

			if (detectedToolCalls.size > 0) {
				await this.sendMessage(
					"Continue based on the tool results above.",
					enrichedContext,
				);
			}
		} catch (error) {
			// Add error message
			const errorMessage: IChatMessage = {
				id: generateUuid(),
				role: "assistant",
				content: `Error: ${error instanceof Error ? error.message : "Unknown error occurred"}`,
				timestamp: Date.now(),
			};

			session.messages.push(errorMessage);
			session.updated = Date.now();
			this._onDidAddMessage.fire(errorMessage);
			this.saveSessions();
		}
	}

	private buildAIMessages(
		session: IChatSession,
		context?: IChatContext,
	): IAIMessage[] {
		const messages: IAIMessage[] = [];

		// Add system message with context and tools
		let systemContent =
			"You are AlphaCode AI, an intelligent coding assistant integrated into AlphaCodeIDE. Help users with code generation, refactoring, debugging, and documentation.";

		// Add tools information
		systemContent +=
			'\n\n## Available Tools\n\nYou have access to the following tools to help users. To use a tool, respond with a tool call in this format:\n\n```tool\n{\n  "name": "tool_name",\n  "parameters": {\n    "param1": "value1"\n  }\n}\n```\n\nAvailable tools:\n';

		const tools = this.toolsRegistry.getAllTools();
		for (const tool of tools) {
			systemContent += `\n### ${tool.name}\n${tool.description}\nParameters: ${JSON.stringify(tool.parameters, null, 2)}\n`;
		}

		if (context) {
			systemContent += "\n\nContext:";
			if (context.activeFile) {
				systemContent += `\nActive file: ${context.activeFile}`;
			}
			if (context.selectedCode) {
				// Mask secrets in selected code before sending to AI
				const maskedCode = this.securityService.maskSecrets(
					context.selectedCode,
				);
				systemContent += `\nSelected code:\n${maskedCode}`;
			}
			if (context.openFiles && context.openFiles.length > 0) {
				systemContent += `\nOpen files: ${context.openFiles.join(", ")}`;
			}
			if (context.workspaceFiles && context.workspaceFiles.length > 0) {
				systemContent += `\nRelevant workspace files:\n${context.workspaceFiles.join("\n")}`;
			}
			if (context.symbols && context.symbols.length > 0) {
				systemContent += `\nWorkspace symbols:\n${context.symbols.join("\n")}`;
			}
			if (context.workspaceSnippets && context.workspaceSnippets.length > 0) {
				systemContent += `\nWorkspace snippets:\n${context.workspaceSnippets.join("\n\n")}`;
			}
		}

		messages.push({
			role: "system",
			content: systemContent,
		});

		// Add conversation history (limit to last 10 messages to avoid token limits)
		const recentMessages = session.messages.slice(-10);
		for (const msg of recentMessages) {
			// Mask secrets in user messages
			const content =
				msg.role === "user"
					? this.securityService.maskSecrets(msg.content)
					: msg.content;

			// Handle tool messages
			if (msg.role === "tool") {
				messages.push({
					role: "assistant",
					content: `Tool result: ${content}`,
				});
			} else {
				messages.push({
					role: msg.role === "user" ? "user" : "assistant",
					content,
				});
			}
		}

		return messages;
	}

	private async getRelevantFiles(
		query: string,
		files: IFileContext[],
	): Promise<IFileContext[]> {
		if (!query.trim()) {
			return files.slice(0, MAX_WORKSPACE_FILE_REFERENCES);
		}
		const relevant = await this.contextService.getRelevantContext(
			query,
			MAX_WORKSPACE_FILE_REFERENCES,
		);
		if (relevant.length > 0) {
			return relevant;
		}
		return files.slice(0, MAX_WORKSPACE_FILE_REFERENCES);
	}

	private createSnippetForFile(file: IFileContext): string | undefined {
		if (!file.content) {
			return undefined;
		}
		const trimmed =
			file.content.length > MAX_SNIPPET_LENGTH
				? `${file.content.slice(0, MAX_SNIPPET_LENGTH)}\n…`
				: file.content;
		return `File: ${file.path}\n${trimmed}`;
	}

	getSessions(): IChatSession[] {
		return Array.from(this.sessions.values()).sort(
			(a, b) => b.updated - a.updated,
		);
	}

	deleteSession(sessionId: string): void {
		this.sessions.delete(sessionId);

		if (this.currentSessionId === sessionId) {
			// Switch to another session or create a new one
			const remainingSessions = Array.from(this.sessions.keys());
			if (remainingSessions.length > 0) {
				this.currentSessionId = remainingSessions[0];
			} else {
				this.createSession();
			}
		}

		this.saveSessions();
	}

	clearCurrentSession(): void {
		const session = this.getCurrentSession();
		if (session) {
			session.messages = [];
			session.updated = Date.now();
			this.saveSessions();
		}
	}

	exportSession(sessionId: string): string {
		const session = this.sessions.get(sessionId);
		if (!session) {
			throw new Error("Session not found");
		}
		return JSON.stringify(session, null, 2);
	}

	getAvailableTools(): IChatTool[] {
		return [...this.toolsRegistry.getAllTools(), ...this.proposalTools];
	}

	async acceptProposal(proposalId: string): Promise<void> {
		const proposal = this.pendingProposals.get(proposalId);
		if (!proposal) {
			throw new Error(`Unknown proposal: ${proposalId}`);
		}
		const message = await this.acceptEditProposal(proposalId);
		this.appendSystemMessage(message);
	}

	async rejectProposal(proposalId: string): Promise<void> {
		const proposal = this.pendingProposals.get(proposalId);
		if (!proposal) {
			throw new Error(`Unknown proposal: ${proposalId}`);
		}
		const message = await this.rejectEditProposal(proposalId);
		this.appendSystemMessage(message);
	}

	hasPendingProposal(proposalId: string): boolean {
		return this.pendingProposals.has(proposalId);
	}

	async executeToolCall(toolCall: IToolCall): Promise<IToolResult> {
		try {
			if (toolCall.name === "accept_edit_proposal") {
				const result = await this.acceptEditProposal(toolCall.parameters.id);
				return { toolCallId: toolCall.id, result };
			}
			if (toolCall.name === "reject_edit_proposal") {
				const result = await this.rejectEditProposal(toolCall.parameters.id);
				return { toolCallId: toolCall.id, result };
			}
			if (toolCall.name === "list_edit_proposals") {
				const result = await this.listEditProposals();
				return { toolCallId: toolCall.id, result };
			}
			const result = await this.toolsRegistry.executeTool(
				toolCall.name,
				toolCall.parameters,
			);
			return {
				toolCallId: toolCall.id,
				result,
			};
		} catch (error) {
			return {
				toolCallId: toolCall.id,
				result: "",
				error:
					error instanceof Error
						? error.message
						: "Unknown error executing tool",
			};
		}
	}

	private async handleToolEditProposal(
		proposal: IToolEditProposal,
	): Promise<string> {
		const id = `proposal-${++this.proposalSequence}`;
		const normalized: IToolEditProposal & { id: string } = {
			...proposal,
			id,
			originalContent: proposal.originalContent ?? "",
			proposedContent: proposal.proposedContent ?? "",
		};
		this.pendingProposals.set(id, normalized);
		await this.openDiffForProposal(normalized);
		return `Edit proposal ${id} created for ${proposal.path}. Use accept_edit_proposal or reject_edit_proposal to finalize.`;
	}

	private async openDiffForProposal(proposal: IToolEditProposal & { id: string }): Promise<void> {
		try {
			const label = `${proposal.kind === "write" ? "Create" : "Edit"}: ${proposal.path}`;
			const originalResource = URI.from({
				scheme: "untitled",
				path: `/alphacode/proposals/${proposal.id}/original/${proposal.path.split(/[\\/]/).pop() ?? "file"}`,
			});
			let modifiedInput: IResourceDiffEditorInput["modified"];
			let modifiedResourceExists = false;
			try {
				modifiedResourceExists = await this.fileService.exists(proposal.uri);
			} catch {
				modifiedResourceExists = false;
			}
			if (modifiedResourceExists) {
				modifiedInput = {
					resource: proposal.uri,
				};
			} else {
				modifiedInput = {
					resource: URI.from({
						scheme: "untitled",
						path: `/alphacode/proposals/${proposal.id}/modified/${proposal.path.split(/[\\/]/).pop() ?? "file"}`,
					}),
					forceUntitled: true,
					contents: proposal.proposedContent,
				};
			}
			const diffInput: IResourceDiffEditorInput = {
				label,
				original: {
					resource: originalResource,
					forceUntitled: true,
					contents: proposal.originalContent,
				},
				modified: modifiedInput,
				options: {
					pinned: true,
				},
			};
			await this.editorService.openEditor(diffInput);
		} catch (error) {
			console.error("Failed to open diff for proposal", error);
		}
	}

	private async acceptEditProposal(id: string): Promise<string> {
		const proposal = this.pendingProposals.get(id);
		if (!proposal) {
			throw new Error(`Unknown proposal: ${id}`);
		}
		await this.fileService.writeFile(
			proposal.uri,
			VSBuffer.fromString(proposal.proposedContent),
		);
		this.pendingProposals.delete(id);
		this.logDecision(proposal, "accepted");
		return `Applied proposal ${id} to ${proposal.path}.`;
	}

	private async rejectEditProposal(id: string): Promise<string> {
		const proposal = this.pendingProposals.get(id);
		if (!proposal) {
			throw new Error(`Unknown proposal: ${id}`);
		}
		this.pendingProposals.delete(id);
		this.logDecision(proposal, "rejected");
		return `Rejected proposal ${id} for ${proposal.path}.`;
	}

	private async listEditProposals(): Promise<string> {
		if (this.pendingProposals.size === 0) {
			return "No pending edit proposals.";
		}
		const lines: string[] = ["Pending proposals:"];
		for (const proposal of this.pendingProposals.values()) {
			lines.push(`- ${proposal.id}: ${proposal.path} (${proposal.kind})`);
		}
		return lines.join("\n");
	}

	private logDecision(
		proposal: IToolEditProposal & { id: string },
		action: "accepted" | "rejected",
	): void {
		this.auditLog.push({
			id: proposal.id,
			path: proposal.path,
			action,
			timestamp: Date.now(),
		});
		if (this.auditLog.length > 200) {
			this.auditLog.splice(0, this.auditLog.length - 200);
		}
		this.persistDecisionLog();
	}

	private loadDecisionLog(): void {
		const stored = this.storageService.get(
			STORAGE_KEY_TOOL_DECISIONS,
			StorageScope.WORKSPACE,
		);
		if (!stored) {
			this.auditLog = [];
			return;
		}
		try {
			const parsed = JSON.parse(stored);
			if (Array.isArray(parsed)) {
				this.auditLog = parsed.filter((entry) =>
					typeof entry?.id === "string" &&
					typeof entry?.path === "string" &&
					(entry?.action === "accepted" || entry?.action === "rejected") &&
					typeof entry?.timestamp === "number",
				);
			}
		} catch {
			this.auditLog = [];
		}
	}

	private persistDecisionLog(): void {
		try {
			this.storageService.store(
				STORAGE_KEY_TOOL_DECISIONS,
				JSON.stringify(this.auditLog),
				StorageScope.WORKSPACE,
				StorageTarget.MACHINE,
			);
		} catch (error) {
			console.error("Failed to persist tool decision log", error);
		}
	}

	private createToolMessage(
		toolCall: IToolCall,
		toolResult: IToolResult,
		timestamp: number,
	): { content: string; metadata: Record<string, any> } {
		const toolDefinition = this.toolsRegistry.getTool(toolCall.name);
		const normalizedContent = this.normalizeToolContent(
			toolResult.error ?? toolResult.result,
		);
		const content =
			normalizedContent.length > 0
				? normalizedContent
				: localize(
					"alphacode.chat.tool.noOutput",
					"The tool did not return any output.",
				  );
		const summaryInfo = this.buildToolSummary(content);
		const metadata: Record<string, any> = {
			name: toolDefinition?.name ?? toolCall.name,
			status: toolResult.error ? "error" : "success",
			summary: summaryInfo.summary,
			timestamp,
		};

		if (toolCall.name === "write_file" || toolCall.name === "edit_file") {
			const proposal = this.findProposalForTool(toolCall);
			if (proposal) {
				metadata.proposalId = proposal.id;
				metadata.originalContent = proposal.originalContent;
				metadata.proposedContent = proposal.proposedContent;
				metadata.path = proposal.path;
			}
		}

		if (toolDefinition?.description) {
			metadata.description = toolDefinition.description;
		}

		const parametersString = this.stringifyToolParameters(toolCall.parameters);
		if (parametersString) {
			metadata.parameters = parametersString;
		}

		if (summaryInfo.details) {
			metadata.details = summaryInfo.details;
		}

		if (toolResult.error) {
			metadata.error = toolResult.error;
		}

		return {
			content,
			metadata,
		};
	}

	private findProposalForTool(toolCall: IToolCall): (IToolEditProposal & { id: string }) | undefined {
		const candidateIds = Array.from(this.pendingProposals.keys());
		for (let i = candidateIds.length - 1; i >= 0; i--) {
			const proposal = this.pendingProposals.get(candidateIds[i]);
			if (!proposal) {
				continue;
			}
			if (toolCall.name === "write_file" && proposal.kind === "write") {
				return proposal;
			}
			if (toolCall.name === "edit_file" && proposal.kind === "edit") {
				return proposal;
			}
		}
		return undefined;
	}

	private buildToolSummary(content: string): {
		summary: string;
		details?: string;
	} {
		const normalized = content.replace(/\r\n/g, "\n").trim();
		if (!normalized) {
			return {
				summary: localize(
					"alphacode.chat.tool.noOutputSummary",
					"No output returned.",
				),
			};
		}

		const previewLimit = 280;
		const paragraphs = normalized
			.split(/\n\s*\n/)
			.map((part) => part.trim())
			.filter((part) => part.length > 0);
		const firstParagraph =
			paragraphs.length > 0 ? paragraphs[0] : normalized;

		if (normalized.length <= previewLimit && paragraphs.length <= 1) {
			return { summary: normalized };
		}

		if (firstParagraph.length <= previewLimit) {
			return {
				summary: firstParagraph,
				details: normalized !== firstParagraph ? normalized : undefined,
			};
		}

		return {
			summary: firstParagraph.slice(0, previewLimit).trimEnd() + "…",
			details: normalized,
		};
	}

	private stringifyToolParameters(parameters: any): string | undefined {
		if (parameters === undefined || parameters === null) {
			return undefined;
		}

		if (typeof parameters === "string") {
			return parameters;
		}

		try {
			const json = JSON.stringify(parameters, null, 2);
			if (!json) {
				return undefined;
			}
			return json.length > 2000 ? `${json.slice(0, 2000)}…` : json;
		} catch (error: unknown) {
			return String(parameters);
		}
	}

	private normalizeToolContent(content: unknown): string {
		if (typeof content === "string") {
			return content.trim();
		}

		if (content === undefined || content === null) {
			return "";
		}

		if (typeof content === "object") {
			try {
				return JSON.stringify(content, null, 2).trim();
			} catch (error: unknown) {
				return String(content).trim();
			}
		}

		return String(content).trim();
	}

	private extractToolCalls(
		content: string,
		state?: { lastIndex: number },
	): IToolCall[] {
		const toolCalls: IToolCall[] = [];
		const length = content.length;
		let searchIndex = state?.lastIndex ?? 0;
		let furthestIndex = searchIndex;

		while (searchIndex < length) {
			const fenceStart = content.indexOf("```tool", searchIndex);
			if (fenceStart === -1) {
				furthestIndex = length;
				break;
			}

			const headerEnd = content.indexOf("\n", fenceStart);
			if (headerEnd === -1) {
				furthestIndex = fenceStart;
				break;
			}

			const blockStart = headerEnd + 1;
			let cursor = blockStart;
			let inString = false;
			let escaped = false;
			let closingIndex = -1;

			while (cursor < length) {
				const code = content.charCodeAt(cursor);

				if (inString) {
					if (escaped) {
						escaped = false;
					} else if (code === 92 /* \\ */) {
						escaped = true;
					} else if (code === 34 /* " */) {
						inString = false;
					}
					cursor++;
					continue;
				}

				if (code === 34 /* " */) {
					inString = true;
					cursor++;
					continue;
				}

				if (
					code === 96 /* ` */ &&
					cursor + 2 < length &&
					content.charCodeAt(cursor + 1) === 96 &&
					content.charCodeAt(cursor + 2) === 96
				) {
					let preceding = cursor - 1;
					while (preceding >= blockStart) {
						const precedingCode = content.charCodeAt(preceding);
						if (precedingCode === 32 /* space */ || precedingCode === 9 /* tab */) {
							preceding--;
							continue;
						}
						if (
							precedingCode === 10 /* \n */ ||
							precedingCode === 13 /* \r */
						) {
							closingIndex = cursor;
						}
						break;
					}
					if (preceding < blockStart) {
						closingIndex = cursor;
					}
					if (closingIndex !== -1) {
						break;
					}
				}

				cursor++;
			}

			if (closingIndex === -1) {
				furthestIndex = fenceStart;
				break;
			}

			const rawBlock = content.slice(blockStart, closingIndex).trim();
			let advanceIndex = closingIndex + 3;
			while (
				advanceIndex < length &&
				(content.charCodeAt(advanceIndex) === 13 || content.charCodeAt(advanceIndex) === 10)
			) {
				advanceIndex++;
			}
			furthestIndex = advanceIndex;
			searchIndex = advanceIndex;

			if (!rawBlock) {
				continue;
			}

			try {
				const toolCallData = JSON.parse(rawBlock);
				if (toolCallData.name && toolCallData.parameters) {
					toolCalls.push({
						id: generateUuid(),
						name: toolCallData.name,
						parameters: toolCallData.parameters,
					});
				}
			} catch (error: unknown) {
				console.error("Failed to parse tool call:", error);
			}
		}

		if (state) {
			state.lastIndex = Math.min(furthestIndex, length);
		}

		return toolCalls;
	}

	private async _ensureChatEditingView(): Promise<void> {
		if (!this.currentSessionId) {
			return;
		}
		const session = this.chatEditingService.getEditingSession(this.currentSessionId);
		if (session) {
			await session.applyPendingEdits();
			await session.show();
		}
	}

	private executeToolCallDuringStreaming(
		session: IChatSession,
		toolCall: IToolCall,
	): Promise<void> {
		return (async () => {
			const toolResult = await this.executeToolCall(toolCall);
			const toolTimestamp = Date.now();
			const formattedTool = this.createToolMessage(
				toolCall,
				toolResult,
				toolTimestamp,
			);

			const toolMessage: IChatMessage = {
				id: generateUuid(),
				role: "tool",
				content: formattedTool.content,
				timestamp: toolTimestamp,
				toolCallId: toolCall.id,
				metadata: formattedTool.metadata,
			};

			session.messages.push(toolMessage);
			session.updated = toolTimestamp;
			this._onDidAddMessage.fire(toolMessage);
			this.saveSessions();
			await this._ensureChatEditingView();
		})();
	}

	private getToolCallKey(toolCall: IToolCall): string {
		try {
			return `${toolCall.name}:${JSON.stringify(toolCall.parameters)}`;
		} catch (error) {
			return `${toolCall.name}:${String(toolCall.parameters)}`;
		}
	}
}
