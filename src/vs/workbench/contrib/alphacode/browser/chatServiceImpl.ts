/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { Emitter, Event } from "../../../../base/common/event.js";
import { Disposable } from "../../../../base/common/lifecycle.js";
import { generateUuid } from "../../../../base/common/uuid.js";
import { VSBuffer } from "../../../../base/common/buffer.js";
import { localize } from "../../../../nls.js";
import {
	IStorageService,
	StorageScope,
	StorageTarget,
} from "../../../../platform/storage/common/storage.js";
import { IAlphaCodeAIService } from "../common/aiService.js";
import { IChatEditingService } from "../../chat/common/chatEditingService.js";
import type { IAIMessage } from "../common/aiProvider.js";
import {
	IAlphaCodeChatService,
	IChatContext,
	IChatMessage,
	IChatSession,
	IStreamChunk,
	IChatTool,
	IToolCall,
	IToolResult,
	IEditProposalWithChanges,
	IProposalDecision,
} from "../common/chatService.js";
import {
	IAlphaCodeContextService,
	type IFileContext,
} from "../common/contextService.js";
import { IAlphaCodeSecurityService } from "../common/securityService.js";
import { ChatToolsRegistry, type IToolEditProposal } from "./chatTools.js";
import { calculateLineChanges, applyChanges, getChangeSummary } from "./diffUtils.js";
import { IFileService } from "../../../../platform/files/common/files.js";
import { IWorkspaceContextService } from "../../../../platform/workspace/common/workspace.js";
import { IEditorService } from "../../../../workbench/services/editor/common/editorService.js";
import type { IResourceDiffEditorInput } from "../../../../workbench/common/editor.js";
import { URI } from "../../../../base/common/uri.js";

const STORAGE_KEY_SESSIONS = "alphacode.chat.sessions";
const STORAGE_KEY_CURRENT_SESSION = "alphacode.chat.currentSession";
const MAX_WORKSPACE_FILE_REFERENCES = 20;
const MAX_WORKSPACE_SYMBOLS = 100;
const MAX_WORKSPACE_SNIPPETS = 6;
const MAX_SNIPPET_LENGTH = 2000;
const STORAGE_KEY_TOOL_DECISIONS = "alphacode.chat.tool.decisions";

interface IToolEditDecisionRecord {
	id: string;
	path: string;
	action: "accepted" | "rejected" | "partially-accepted";
	timestamp: number;
}

export class AlphaCodeChatService
	extends Disposable
	implements IAlphaCodeChatService
{
	declare readonly _serviceBrand: undefined;

	private readonly _onDidAddMessage = this._register(
		new Emitter<IChatMessage>(),
	);
	readonly onDidAddMessage: Event<IChatMessage> = this._onDidAddMessage.event;

	private readonly _onDidCreateSession = this._register(
		new Emitter<IChatSession>(),
	);
	readonly onDidCreateSession: Event<IChatSession> =
		this._onDidCreateSession.event;

	private readonly _onDidStreamChunk = this._register(
		new Emitter<IStreamChunk>(),
	);
	readonly onDidStreamChunk: Event<IStreamChunk> = this._onDidStreamChunk.event;

	private readonly _onDidCreateProposal = this._register(
		new Emitter<IEditProposalWithChanges>(),
	);
	readonly onDidCreateProposal: Event<IEditProposalWithChanges> =
		this._onDidCreateProposal.event;

	private readonly _onDidChangeProposalStatus = this._register(
		new Emitter<IEditProposalWithChanges>(),
	);
	readonly onDidChangeProposalStatus: Event<IEditProposalWithChanges> =
		this._onDidChangeProposalStatus.event;
	private sessions: Map<string, IChatSession> = new Map();
	private currentSessionId: string | undefined;
	private toolsRegistry: ChatToolsRegistry;
	private pendingProposals: Map<string, IEditProposalWithChanges> = new Map();
	private readonly proposalTools: IChatTool[];
	private auditLog: IToolEditDecisionRecord[] = [];
	private proposalSequence = 0;
	private backupContents: Map<string, string> = new Map();
	private currentStreamAbortController: AbortController | undefined;

	constructor(
		@IAlphaCodeAIService private readonly aiService: IAlphaCodeAIService,
		@IStorageService private readonly storageService: IStorageService,
		@IAlphaCodeSecurityService
		private readonly securityService: IAlphaCodeSecurityService,
		@IAlphaCodeContextService
		private readonly contextService: IAlphaCodeContextService,
		@IFileService private readonly fileService: IFileService,
		@IWorkspaceContextService workspaceContextService: IWorkspaceContextService,
		@IEditorService private readonly editorService: IEditorService,
		@IChatEditingService private readonly chatEditingService: IChatEditingService,
	) {
		super();
		this.loadDecisionLog();
		this.toolsRegistry = new ChatToolsRegistry(
			fileService,
			workspaceContextService,
			this.handleToolEditProposal.bind(this),
		);
		this.proposalTools = [
			{
				name: "accept_edit_proposal",
				description:
					"Accept a pending edit proposal previously generated by a tool.",
				parameters: {
					type: "object",
					properties: {
						id: {
							type: "string",
							description: "The proposal identifier returned when the diff was created.",
						},
					},
					required: ["id"],
				},
				execute: async (params: { id: string }) =>
					await this.acceptEditProposal(params.id),
			},
			{
				name: "reject_edit_proposal",
				description:
					"Reject and discard a pending edit proposal without applying changes.",
				parameters: {
					type: "object",
					properties: {
						id: {
							type: "string",
							description: "The proposal identifier returned when the diff was created.",
						},
					},
					required: ["id"],
				},
				execute: async (params: { id: string }) =>
					await this.rejectEditProposal(params.id),
			},
			{
				name: "list_edit_proposals",
				description:
					"List all pending edit proposals awaiting approval.",
				parameters: {
					type: "object",
					properties: {},
				},
				execute: async () => this.listEditProposals(),
			},
		];
		this.loadSessions();
	}

	private appendSystemMessage(content: string): void {
		const session = this.getCurrentSession();
		if (!session) {
			return;
		}
		const message: IChatMessage = {
			id: generateUuid(),
			role: "system",
			content,
			timestamp: Date.now(),
		};
		session.messages.push(message);
		session.updated = Date.now();
		this._onDidAddMessage.fire(message);
		this.saveSessions();
	}

	private loadSessions(): void {
		const stored = this.storageService.get(
			STORAGE_KEY_SESSIONS,
			StorageScope.WORKSPACE,
		);
		if (stored) {
			try {
				const sessions: IChatSession[] = JSON.parse(stored);
				sessions.forEach((session) => this.sessions.set(session.id, session));
			} catch (error) {
				console.error("Failed to parse chat sessions", error);
			}
		}

		const currentId = this.storageService.get(
			STORAGE_KEY_CURRENT_SESSION,
			StorageScope.WORKSPACE,
		);
		if (currentId && this.sessions.has(currentId)) {
			this.currentSessionId = currentId;
		}

		if (this.sessions.size === 0) {
			this.createSession();
		}
	}

	private saveSessions(): void {
		const sessionsArray = Array.from(this.sessions.values());
		this.storageService.store(
			STORAGE_KEY_SESSIONS,
			JSON.stringify(sessionsArray),
			StorageScope.WORKSPACE,
			StorageTarget.MACHINE,
		);

		if (this.currentSessionId) {
			this.storageService.store(
				STORAGE_KEY_CURRENT_SESSION,
				this.currentSessionId,
				StorageScope.WORKSPACE,
				StorageTarget.MACHINE,
			);
		}
	}

	getCurrentSession(): IChatSession | undefined {
		if (!this.currentSessionId) {
			return undefined;
		}
		return this.sessions.get(this.currentSessionId);
	}

	createSession(title?: string): IChatSession {
		const session: IChatSession = {
			id: generateUuid(),
			title: title || `Session ${this.sessions.size + 1}`,
			messages: [],
			created: Date.now(),
			updated: Date.now(),
		};

		this.sessions.set(session.id, session);
		this.currentSessionId = session.id;
		this.saveSessions();
		this._onDidCreateSession.fire(session);

		return session;
	}

	switchSession(sessionId: string): void {
		if (this.sessions.has(sessionId)) {
			this.currentSessionId = sessionId;
			this.saveSessions();
		}
	}

	async sendMessage(content: string, context?: IChatContext): Promise<void> {
		return this._sendMessage(content, context, false);
	}

	async sendMessageHidden(content: string, context?: IChatContext): Promise<void> {
		return this._sendMessage(content, context, true);
	}

	private async _sendMessage(content: string, context?: IChatContext, hidden: boolean = false): Promise<void> {
		const session = this.getCurrentSession();
		if (!session) {
			throw new Error("No active chat session");
		}

		// Add user message
		const userMessage: IChatMessage = {
			id: generateUuid(),
			role: "user",
			content,
			timestamp: Date.now(),
			hidden, // Marquer comme caché si c'est un message système
		};

		session.messages.push(userMessage);
		session.updated = Date.now();
		if (!hidden) {
			// Ne pas notifier l'UI pour les messages cachés
			this._onDidAddMessage.fire(userMessage);
		}
		this.saveSessions();

		let enrichedContext = context;
		const workspaceContext = await this.contextService.getWorkspaceContext();
		const relevantFiles = await this.getRelevantFiles(
			content,
			workspaceContext.files,
		);
		const workspaceFiles = relevantFiles.map((file) => file.path);
		const workspaceSnippets = relevantFiles
			.slice(0, MAX_WORKSPACE_SNIPPETS)
			.map((file) => this.createSnippetForFile(file));
		const symbolEntries = workspaceContext.symbols
			.slice(0, MAX_WORKSPACE_SYMBOLS)
			.map(
				(symbol) =>
					`${symbol.kind}: ${symbol.name} (${symbol.location.uri.path})`,
			);
		if (
			!enrichedContext ||
			enrichedContext.workspaceFiles === undefined ||
			enrichedContext.symbols === undefined ||
			enrichedContext.workspaceSnippets === undefined
		) {
			enrichedContext = {
				...context,
				workspaceFiles,
				symbols: symbolEntries,
				workspaceSnippets: workspaceSnippets.filter(Boolean) as string[],
			};
		} else {
			enrichedContext.workspaceFiles =
				enrichedContext.workspaceFiles ?? workspaceFiles;
			enrichedContext.symbols = enrichedContext.symbols ?? symbolEntries;
			enrichedContext.workspaceSnippets =
				enrichedContext.workspaceSnippets ??
				(workspaceSnippets.filter(Boolean) as string[]);
		}

		const aiMessages: IAIMessage[] = this.buildAIMessages(
			session,
			enrichedContext,
		);

		try {
			// Create abort controller for this stream
			this.currentStreamAbortController = new AbortController();
			const messageId = generateUuid();
			let fullContent = "";
			let displayContent = "";
			let assistantMessage: IChatMessage | undefined;
			const detectedToolCalls = new Map<string, IToolCall>();
			const writeToolExecutionPromises: Promise<void>[] = [];
			const readToolCalls: IToolCall[] = [];
			const toolExtractionState = { lastIndex: 0 };
			let writeToolDetected = false;

			await this.aiService.sendMessageStream(aiMessages, async (chunk) => {
				// Check if aborted
				if (this.currentStreamAbortController?.signal.aborted) {
					throw new DOMException('Stream aborted', 'AbortError');
				}
				if (!chunk.done) {
					fullContent += chunk.content;
					
					// Nettoyer le contenu affiché en retirant tous les blocs ```tool...```
					displayContent = this.removeToolBlocks(fullContent);
					
					// Détecter si un outil d'ÉCRITURE commence (write_file, edit_file)
					const writeToolMatch = fullContent.match(/```tool[\s\S]*?"name"\s*:\s*"(write_file|edit_file)"/i);
					if (writeToolMatch && !writeToolDetected) {
						writeToolDetected = true;
						
						// Signaler la fin du stream pour l'affichage
						this._onDidStreamChunk.fire({ content: "", done: true, messageId });
					}
					
					if (!assistantMessage && displayContent.trim().length > 0) {
						assistantMessage = {
							id: messageId,
							role: "assistant",
							content: displayContent,
							timestamp: Date.now(),
						};
						session.messages.push(assistantMessage);
						session.updated = Date.now();
						this._onDidAddMessage.fire(assistantMessage);
						this.saveSessions();
						await this._ensureChatEditingView();
					} else if (assistantMessage) {
						assistantMessage.content = displayContent;
						assistantMessage.timestamp = Date.now();
					}

					// Ne diffuser que si pas d'outil d'écriture détecté
					if (!writeToolDetected) {
						this._onDidStreamChunk.fire({
							content: chunk.content,
							done: false,
							messageId,
						});
					}

					// Toujours extraire les tools du contenu complet
					const toolCallsInContent = this.extractToolCalls(
						fullContent,
						toolExtractionState,
					);
					for (const toolCall of toolCallsInContent) {
						const key = this.getToolCallKey(toolCall);
						if (!detectedToolCalls.has(key)) {
							detectedToolCalls.set(key, toolCall);
							
							// Différencier outils de lecture vs écriture
							if (this.isWriteTool(toolCall.name)) {
								// Outils d'écriture: exécuter immédiatement
								writeToolExecutionPromises.push(
									this.executeToolCallDuringStreaming(session, toolCall),
								);
							} else {
								// Outils de lecture: collecter pour exécution après le streaming
								readToolCalls.push(toolCall);
							}
						}
					}
				} else {
					if (!writeToolDetected) {
						this._onDidStreamChunk.fire({ content: "", done: true, messageId });
					}
				}
			});

			// Clear abort controller
			this.currentStreamAbortController = undefined;

			// Attendre que tous les outils d'ÉCRITURE soient exécutés
			await Promise.all(writeToolExecutionPromises);

			// Maintenant exécuter tous les outils de LECTURE groupés
			if (readToolCalls.length > 0) {
				for (const toolCall of readToolCalls) {
					await this.executeToolCallDuringStreaming(session, toolCall);
				}
			}

			// Ne créer un message assistant que s'il y a du contenu à afficher
			if (!assistantMessage && displayContent.trim().length > 0) {
				assistantMessage = {
					id: messageId,
					role: "assistant",
					content: displayContent,
					timestamp: Date.now(),
				};
				session.messages.push(assistantMessage);
				session.updated = Date.now();
				this._onDidAddMessage.fire(assistantMessage);
				await this._ensureChatEditingView();
			}

			if (assistantMessage && displayContent.trim().length > 0) {
				assistantMessage.content = displayContent;
				assistantMessage.timestamp = Date.now();
				if (detectedToolCalls.size > 0) {
					assistantMessage.toolCalls = Array.from(
						detectedToolCalls.values(),
					);
				} else {
					delete assistantMessage.toolCalls;
				}
			}

			// Les outils ont été exécutés, les résultats sont déjà dans les messages
			// Pas besoin de demander un résumé supplémentaire qui perturbe l'affichage
		} catch (error) {
			// Clear abort controller
			this.currentStreamAbortController = undefined;

			// Si c'est une annulation, ne pas afficher d'erreur
			if (error instanceof Error && error.name === "AbortError") {
				return;
			}

			const errorMessage: IChatMessage = {
				id: generateUuid(),
				role: "assistant",
				content: `Error: ${error instanceof Error ? error.message : "Unknown error"}`,
				timestamp: Date.now(),
			};

			session.messages.push(errorMessage);
			session.updated = Date.now();
			this._onDidAddMessage.fire(errorMessage);
			this.saveSessions();
		}
	}

	private buildAIMessages(
		session: IChatSession,
		context?: IChatContext,
	): IAIMessage[] {
		const messages: IAIMessage[] = [];

		let systemContent =
			"You are AlphaCode AI, an intelligent coding assistant integrated into AlphaCodeIDE. Help users with code generation, refactoring, debugging, and documentation.";

		systemContent +=
			'\n\n## Available Tools\n\nYou have access to powerful tools to help users. When you use a tool, it will be executed IMMEDIATELY in real-time as you write it. For file editing tools (write_file, edit_file), a diff view will automatically open for the user to review your changes.\n\n### Tool Call Format\n\nTo use a tool, respond with a tool call in this exact format:\n\n```tool\n{\n  "name": "tool_name",\n  "parameters": {\n    "param1": "value1",\n    "param2": "value2"\n  }\n}\n```\n\n**IMPORTANT**: \n- The tool block will be executed as soon as it\'s complete (you don\'t need to finish your entire message)\n- For write_file and edit_file tools, a diff editor will open automatically showing changes in red (deletions) and green (additions)\n- The user can accept or reject changes from the diff view\n- You can continue explaining after using a tool\n\n### Example\n\nUser: "Create a hello world function in Python"\n\nYou can respond:\n\nI\'ll create a Python file with a hello world function:\n\n```tool\n{\n  "name": "write_file",\n  "parameters": {\n    "path": "hello.py",\n    "content": "def hello_world():\\n    print(\\"Hello, World!\\")\\n\\nif __name__ == \\"__main__\\":\\n    hello_world()"\n  }\n}\n```\n\nThis will create a new Python file with a simple hello world function. The diff editor is now open for your review.\n\n## Available Tools:\n';

		const tools = this.toolsRegistry.getAllTools();
		for (const tool of tools) {
			systemContent += `\n### ${tool.name}\n${tool.description}\nParameters: ${JSON.stringify(tool.parameters, null, 2)}\n`;
		}

		if (context) {
			systemContent += "\n\nContext:";
			if (context.activeFile) {
				systemContent += `\nActive file: ${context.activeFile}`;
			}
			if (context.selectedCode) {
				// Mask secrets in selected code before sending to AI
				const maskedCode = this.securityService.maskSecrets(
					context.selectedCode,
				);
				systemContent += `\nSelected code:\n${maskedCode}`;
			}
			if (context.openFiles && context.openFiles.length > 0) {
				systemContent += `\nOpen files: ${context.openFiles.join(", ")}`;
			}
			if (context.workspaceFiles && context.workspaceFiles.length > 0) {
				systemContent += `\nRelevant workspace files:\n${context.workspaceFiles.join("\n")}`;
			}
			if (context.symbols && context.symbols.length > 0) {
				systemContent += `\nWorkspace symbols:\n${context.symbols.join("\n")}`;
			}
			if (context.workspaceSnippets && context.workspaceSnippets.length > 0) {
				systemContent += `\nWorkspace snippets:\n${context.workspaceSnippets.join("\n\n")}`;
			}
		}

		messages.push({
			role: "system",
			content: systemContent,
		});

		const recentMessages = session.messages.slice(-10);
		for (const msg of recentMessages) {
			// Mask secrets in user messages
			const content =
				msg.role === "user"
					? this.securityService.maskSecrets(msg.content)
					: msg.content;

			if (msg.role === "tool") {
				messages.push({
					role: "assistant",
					content: `Tool result: ${content}`,
				});
			} else {
				messages.push({
					role: msg.role === "user" ? "user" : "assistant",
					content,
				});
			}
		}

		return messages;
	}

	private async getRelevantFiles(
		query: string,
		files: IFileContext[],
	): Promise<IFileContext[]> {
		const relevant = await this.contextService.getRelevantContext(
			query,
			MAX_WORKSPACE_FILE_REFERENCES,
		);
		if (relevant.length > 0) {
			return relevant;
		}
		return files.slice(0, MAX_WORKSPACE_FILE_REFERENCES);
	}

	private createSnippetForFile(file: IFileContext): string | undefined {
		if (!file.content) {
			return undefined;
		}
		const trimmed =
			file.content.length > MAX_SNIPPET_LENGTH
				? `${file.content.slice(0, MAX_SNIPPET_LENGTH)}\n…`
				: file.content;
		return `File: ${file.path}\n${trimmed}`;
	}

	getSessions(): IChatSession[] {
		return Array.from(this.sessions.values()).sort(
			(a, b) => b.updated - a.updated,
		);
	}

	deleteSession(sessionId: string): void {
		this.sessions.delete(sessionId);

		if (this.currentSessionId === sessionId) {
			const remainingSessions = Array.from(this.sessions.keys());
			if (remainingSessions.length > 0) {
				this.currentSessionId = remainingSessions[0];
			} else {
				this.createSession();
			}
		}

		this.saveSessions();
	}

	clearCurrentSession(): void {
		const session = this.getCurrentSession();
		if (session) {
			session.messages = [];
			session.updated = Date.now();
			this.saveSessions();
		}
	}

	exportSession(sessionId: string): string {
		const session = this.sessions.get(sessionId);
		if (!session) {
			throw new Error("Session not found");
		}
		return JSON.stringify(session, null, 2);
	}

	getAvailableTools(): IChatTool[] {
		return [...this.toolsRegistry.getAllTools(), ...this.proposalTools];
	}

	async acceptProposal(proposalId: string): Promise<void> {
		const proposal = this.pendingProposals.get(proposalId);
		if (!proposal) {
			throw new Error(`Unknown proposal: ${proposalId}`);
		}
		const message = await this.acceptEditProposal(proposalId);
		this.appendSystemMessage(message);
	}

	async rejectProposal(proposalId: string): Promise<void> {
		const proposal = this.pendingProposals.get(proposalId);
		if (!proposal) {
			throw new Error(`Unknown proposal: ${proposalId}`);
		}
		const message = await this.rejectEditProposal(proposalId);
		this.appendSystemMessage(message);
	}

	hasPendingProposal(proposalId: string): boolean {
		return this.pendingProposals.has(proposalId);
	}

	async executeToolCall(toolCall: IToolCall): Promise<IToolResult> {
		try {
			if (toolCall.name === "accept_edit_proposal") {
				const result = await this.acceptEditProposal(toolCall.parameters.id);
				return { toolCallId: toolCall.id, result };
			}
			if (toolCall.name === "reject_edit_proposal") {
				const result = await this.rejectEditProposal(toolCall.parameters.id);
				return { toolCallId: toolCall.id, result };
			}
			if (toolCall.name === "list_edit_proposals") {
				const result = await this.listEditProposals();
				return { toolCallId: toolCall.id, result };
			}
			const result = await this.toolsRegistry.executeTool(
				toolCall.name,
				toolCall.parameters,
			);
			return {
				toolCallId: toolCall.id,
				result,
			};
		} catch (error) {
			return {
				toolCallId: toolCall.id,
				result: "",
				error:
					error instanceof Error
						? error.message
						: "Unknown error executing tool",
			};
		}
	}

	private async handleToolEditProposal(
		proposal: IToolEditProposal,
	): Promise<string> {
		const id = `proposal-${++this.proposalSequence}`;
		const changes = calculateLineChanges(
			proposal.originalContent ?? "",
			proposal.proposedContent ?? "",
		);
		const enhancedProposal: IEditProposalWithChanges = {
			id,
			path: proposal.path,
			filePath: proposal.uri.fsPath,
			kind: proposal.kind,
			originalContent: proposal.originalContent ?? "",
			proposedContent: proposal.proposedContent ?? "",
			changes,
			timestamp: Date.now(),
			status: 'pending',
		};
		
		// Save backup for potential rollback
		this.backupContents.set(id, proposal.originalContent ?? "");
		
		this.pendingProposals.set(id, enhancedProposal);
		this._onDidCreateProposal.fire(enhancedProposal);
		
		// Open diff editor immediately
		await this.openDiffForProposal(enhancedProposal);
		
		const summary = getChangeSummary(changes);
		return `Edit proposal ${id} created for ${proposal.path}. ${summary}. The diff editor is now open for review. Use accept_edit_proposal or reject_edit_proposal to finalize.`;
	}

	private async openDiffForProposal(proposal: IEditProposalWithChanges): Promise<void> {
		try {
			const label = `${proposal.kind === "write" ? "Create" : "Edit"}: ${proposal.path}`;
			const fileName = proposal.path.split(/[\/]/).pop() ?? "file";
			
			// Create unique URIs for the diff view
			const originalResource = URI.from({
				scheme: "untitled",
				path: `/alphacode/original/${proposal.id}/${fileName}`,
			});
			const modifiedResource = URI.from({
				scheme: "untitled",
				path: `/alphacode/modified/${proposal.id}/${fileName}`,
			});
			
			const diffInput: IResourceDiffEditorInput = {
				label,
				description: `${proposal.path} (${proposal.changes.length} change${proposal.changes.length > 1 ? 's' : ''})`,
				original: {
					resource: originalResource,
					forceUntitled: true,
					contents: proposal.originalContent,
					label: proposal.kind === "write" ? "Empty File" : "Original",
				},
				modified: {
					resource: modifiedResource,
					forceUntitled: true,
					contents: proposal.proposedContent,
					label: "Proposed Changes",
				},
				options: {
					pinned: true,
					preserveFocus: false, // Give focus to the diff editor
					revealIfVisible: true,
					activation: 1, // EditorActivation.ACTIVATE
				},
			};
			
			await this.editorService.openEditor(diffInput);
		} catch (error) {
			console.error("Failed to open diff for proposal:", error);
			throw error;
		}
	}

	private async acceptEditProposal(id: string): Promise<string> {
		const proposal = this.pendingProposals.get(id);
		if (!proposal) {
			throw new Error(`Unknown proposal: ${id}`);
		}
		
		const uri = URI.file(proposal.filePath);
		await this.fileService.writeFile(
			uri,
			VSBuffer.fromString(proposal.proposedContent),
		);
		
		// Update proposal status
		proposal.status = 'accepted';
		this._onDidChangeProposalStatus.fire(proposal);
		
		this.pendingProposals.delete(id);
		this.backupContents.delete(id);
		this.logDecision(proposal, "accepted");
		
		return `✓ Applied proposal ${id} to ${proposal.path}.`;
	}

	private async rejectEditProposal(id: string): Promise<string> {
		const proposal = this.pendingProposals.get(id);
		if (!proposal) {
			throw new Error(`Unknown proposal: ${id}`);
		}
		
		// Perform rollback - restore original content if file was modified
		const backup = this.backupContents.get(id);
		if (backup !== undefined) {
			try {
				const uri = URI.file(proposal.filePath);
				// Check if file exists and was modified
				try {
					const currentContent = await this.fileService.readFile(uri);
					if (currentContent.value.toString() !== backup) {
						// Rollback to original content
						await this.fileService.writeFile(uri, VSBuffer.fromString(backup));
					}
				} catch (error) {
					// File might not exist yet, that's ok
				}
			} catch (error) {
				console.error("Failed to rollback:", error);
			}
		}
		
		// Update proposal status
		proposal.status = 'rejected';
		this._onDidChangeProposalStatus.fire(proposal);
		
		this.pendingProposals.delete(id);
		this.backupContents.delete(id);
		this.logDecision(proposal, "rejected");
		
		return `✗ Rejected proposal ${id} for ${proposal.path}. Changes have been rolled back.`;
	}

	private async listEditProposals(): Promise<string> {
		if (this.pendingProposals.size === 0) {
			return "No pending edit proposals.";
		}
		const lines: string[] = ["Pending proposals:"];
		for (const proposal of this.pendingProposals.values()) {
			lines.push(`- ${proposal.id}: ${proposal.path} (${proposal.kind})`);
		}
		return lines.join("\n");
	}

	private logDecision(
		proposal: IEditProposalWithChanges,
		action: "accepted" | "rejected" | "partially-accepted",
	): void {
		this.auditLog.push({
			id: proposal.id,
			path: proposal.path,
			action,
			timestamp: Date.now(),
		});
		if (this.auditLog.length > 200) {
			this.auditLog.splice(0, this.auditLog.length - 200);
		}
		this.persistDecisionLog();
	}

	private loadDecisionLog(): void {
		const stored = this.storageService.get(
			STORAGE_KEY_TOOL_DECISIONS,
			StorageScope.WORKSPACE,
		);
		if (!stored) {
			this.auditLog = [];
			return;
		}
		try {
			const parsed = JSON.parse(stored);
			if (Array.isArray(parsed)) {
				this.auditLog = parsed.filter((entry) =>
					typeof entry?.id === "string" &&
					typeof entry?.path === "string" &&
					(entry?.action === "accepted" || entry?.action === "rejected" || entry?.action === "partially-accepted") &&
					typeof entry?.timestamp === "number",
				);
			}
		} catch {
			this.auditLog = [];
		}
	}

	private persistDecisionLog(): void {
		try {
			this.storageService.store(
				STORAGE_KEY_TOOL_DECISIONS,
				JSON.stringify(this.auditLog),
				StorageScope.WORKSPACE,
				StorageTarget.MACHINE,
			);
		} catch (error) {
			console.error("Failed to persist tool decision log", error);
		}
	}

	private createToolMessage(
		toolCall: IToolCall,
		toolResult: IToolResult,
		timestamp: number,
	): { content: string; metadata: Record<string, any> } {
		const toolDefinition = this.toolsRegistry.getTool(toolCall.name);
		const normalizedContent = this.normalizeToolContent(
			toolResult.error ?? toolResult.result,
		);
		const content =
			normalizedContent.length > 0
				? normalizedContent
				: localize(
					"alphacode.chat.tool.noOutput",
					"The tool did not return any output.",
				  );
		const summaryInfo = this.buildToolSummary(content);
		const metadata: Record<string, any> = {
			name: toolDefinition?.name ?? toolCall.name,
			status: toolResult.error ? "error" : "success",
			summary: summaryInfo.summary,
			timestamp,
		};

		if (toolCall.name === "write_file" || toolCall.name === "edit_file") {
			const proposal = this.findProposalForTool(toolCall);
			if (proposal) {
				metadata.proposalId = proposal.id;
				metadata.originalContent = proposal.originalContent;
				metadata.proposedContent = proposal.proposedContent;
				metadata.path = proposal.path;
			}
		}

		if (toolDefinition?.description) {
			metadata.description = toolDefinition.description;
		}

		const parametersString = this.stringifyToolParameters(toolCall.parameters);
		if (parametersString) {
			metadata.parameters = parametersString;
		}

		if (summaryInfo.details) {
			metadata.details = summaryInfo.details;
		}

		if (toolResult.error) {
			metadata.error = toolResult.error;
		}

		return {
			content,
			metadata,
		};
	}

	private findProposalForTool(toolCall: IToolCall): IEditProposalWithChanges | undefined {
		const candidateIds = Array.from(this.pendingProposals.keys());
		for (let i = candidateIds.length - 1; i >= 0; i--) {
			const proposal = this.pendingProposals.get(candidateIds[i]);
			if (!proposal) {
				continue;
			}
			if (toolCall.name === "write_file" && proposal.kind === "write") {
				return proposal;
			}
			if (toolCall.name === "edit_file" && proposal.kind === "edit") {
				return proposal;
			}
		}
		return undefined;
	}

	private buildToolSummary(content: string): {
		summary: string;
		details?: string;
	} {
		const normalized = content.replace(/\r\n/g, "\n").trim();
		if (!normalized) {
			return {
				summary: localize(
					"alphacode.chat.tool.noOutputSummary",
					"No output returned.",
				),
			};
		}

		const previewLimit = 280;
		const paragraphs = normalized
			.split(/\n\s*\n/)
			.map((part) => part.trim())
			.filter((part) => part.length > 0);
		const firstParagraph =
			paragraphs.length > 0 ? paragraphs[0] : normalized;

		if (normalized.length <= previewLimit && paragraphs.length <= 1) {
			return { summary: normalized };
		}

		if (firstParagraph.length <= previewLimit) {
			return {
				summary: firstParagraph,
				details: normalized !== firstParagraph ? normalized : undefined,
			};
		}

		return {
			summary: firstParagraph.slice(0, previewLimit).trimEnd() + "…",
			details: normalized,
		};
	}

	private stringifyToolParameters(parameters: any): string | undefined {
		if (parameters === undefined || parameters === null) {
			return undefined;
		}

		if (typeof parameters === "string") {
			return parameters;
		}

		try {
			const json = JSON.stringify(parameters, null, 2);
			if (!json) {
				return undefined;
			}
			return json.length > 2000 ? `${json.slice(0, 2000)}…` : json;
		} catch (error: unknown) {
			return String(parameters);
		}
	}

	private normalizeToolContent(content: unknown): string {
		if (typeof content === "string") {
			return content.trim();
		}

		if (content === undefined || content === null) {
			return "";
		}

		if (typeof content === "object") {
			try {
				return JSON.stringify(content, null, 2).trim();
			} catch (error: unknown) {
				return String(content).trim();
			}
		}

		return String(content).trim();
	}

	private extractToolCalls(
		content: string,
		state?: { lastIndex: number },
	): IToolCall[] {
		const toolCalls: IToolCall[] = [];
		const length = content.length;
		let searchIndex = state?.lastIndex ?? 0;
		let furthestIndex = searchIndex;

		while (searchIndex < length) {
			// Search for ``` first, then verify if followed by "tool"
			// This handles streaming where ```tool may arrive in fragments
			const fenceStart = content.indexOf("```", searchIndex);
			
			if (fenceStart === -1) {
				furthestIndex = length;
				break;
			}
			
			// Check if followed by "tool"
			const afterFence = fenceStart + 3;
			const nextChars = content.substring(afterFence, afterFence + 10);
			
			// Accept "tool" immediately after ```
			const toolMatch = nextChars.match(/^(tool)/);
			if (!toolMatch) {
				// Not a tool block, search for next
				searchIndex = fenceStart + 3;
				continue;
			}

			const headerEnd = content.indexOf("\n", fenceStart);
			if (headerEnd === -1) {
				furthestIndex = fenceStart;
				break;
			}

			const blockStart = headerEnd + 1;
			let cursor = blockStart;
			let inString = false;
			let escaped = false;
			let closingIndex = -1;

			while (cursor < length) {
				const code = content.charCodeAt(cursor);

				if (inString) {
					if (escaped) {
						escaped = false;
					} else if (code === 92 /* \\ */) {
						escaped = true;
					} else if (code === 34 /* " */) {
						inString = false;
					}
					cursor++;
					continue;
				}

				if (code === 34 /* " */) {
					inString = true;
					cursor++;
					continue;
				}

				if (
					code === 96 /* ` */ &&
					cursor + 2 < length &&
					content.charCodeAt(cursor + 1) === 96 &&
					content.charCodeAt(cursor + 2) === 96
				) {
					let preceding = cursor - 1;
					while (preceding >= blockStart) {
						const precedingCode = content.charCodeAt(preceding);
						if (precedingCode === 32 /* space */ || precedingCode === 9 /* tab */) {
							preceding--;
							continue;
						}
						if (
							precedingCode === 10 /* \n */ ||
							precedingCode === 13 /* \r */
						) {
							closingIndex = cursor;
						}
						break;
					}
					if (preceding < blockStart) {
						closingIndex = cursor;
					}
					if (closingIndex !== -1) {
						break;
					}
				}

				cursor++;
			}

			if (closingIndex === -1) {
				furthestIndex = fenceStart;
				break;
			}

			const rawBlock = content.slice(blockStart, closingIndex).trim();
			let advanceIndex = closingIndex + 3;
			while (
				advanceIndex < length &&
				(content.charCodeAt(advanceIndex) === 13 || content.charCodeAt(advanceIndex) === 10)
			) {
				advanceIndex++;
			}
			furthestIndex = advanceIndex;
			searchIndex = advanceIndex;

			if (!rawBlock) {
				continue;
			}

			try {
				const toolCallData = JSON.parse(rawBlock);
				if (toolCallData.name && toolCallData.parameters) {
					toolCalls.push({
						id: generateUuid(),
						name: toolCallData.name,
						parameters: toolCallData.parameters,
					});
				}
			} catch (error: unknown) {
				console.error('Failed to parse tool call:', error);
			}
		}

		if (state) {
			state.lastIndex = Math.min(furthestIndex, length);
		}

		return toolCalls;
	}

	private async _ensureChatEditingView(): Promise<void> {
		if (!this.currentSessionId) {
			return;
		}
		const session = this.chatEditingService.getEditingSession(this.currentSessionId);
		if (session) {
			await session.applyPendingEdits();
			await session.show();
		}
	}

	private executeToolCallDuringStreaming(
		session: IChatSession,
		toolCall: IToolCall,
	): Promise<void> {
		return (async () => {
			const toolResult = await this.executeToolCall(toolCall);
			const toolTimestamp = Date.now();
			const formattedTool = this.createToolMessage(
				toolCall,
				toolResult,
				toolTimestamp,
			);

			const toolMessage: IChatMessage = {
				id: generateUuid(),
				role: "tool",
				content: formattedTool.content,
				timestamp: toolTimestamp,
				toolCallId: toolCall.id,
				metadata: formattedTool.metadata,
			};

			session.messages.push(toolMessage);
			session.updated = toolTimestamp;
			this._onDidAddMessage.fire(toolMessage);
			this.saveSessions();
			await this._ensureChatEditingView();
		})();
	}

	private getToolCallKey(toolCall: IToolCall): string {
		try {
			return `${toolCall.name}:${JSON.stringify(toolCall.parameters)}`;
		} catch (error) {
			return `${toolCall.name}:${String(toolCall.parameters)}`;
		}
	}

	private isWriteTool(toolName: string): boolean {
		// Outils qui modifient des fichiers et doivent arrêter le streaming
		const writeTools = ['write_file', 'edit_file', 'delete_file'];
		return writeTools.includes(toolName);
	}

	private removeToolBlocks(content: string): string {
		// Retirer tous les blocs ```tool...``` du contenu pour l'affichage
		// Les outils seront affichés via les messages "tool" dédiés
		return content.replace(/```tool[\s\S]*?```/g, '').trim();
	}

	// New granular control methods for Phase 3

	getPendingProposals(): IEditProposalWithChanges[] {
		return Array.from(this.pendingProposals.values())
			.filter(p => p.status === 'pending')
			.sort((a, b) => b.timestamp - a.timestamp);
	}

	getProposal(proposalId: string): IEditProposalWithChanges | undefined {
		return this.pendingProposals.get(proposalId);
	}

	async applyProposalDecision(decision: IProposalDecision): Promise<void> {
		const proposal = this.pendingProposals.get(decision.proposalId);
		if (!proposal) {
			throw new Error(`Proposal ${decision.proposalId} not found`);
		}

		switch (decision.action) {
			case 'accept-all':
				await this.acceptEditProposal(decision.proposalId);
				break;

			case 'reject-all':
				await this.rejectEditProposal(decision.proposalId);
				break;

			case 'accept-changes':
				if (!decision.changeIndexes || decision.changeIndexes.length === 0) {
					throw new Error('No change indexes provided for accept-changes action');
				}
				await this.applyPartialChanges(proposal, decision.changeIndexes, true);
				break;

			case 'reject-changes':
				if (!decision.changeIndexes || decision.changeIndexes.length === 0) {
					throw new Error('No change indexes provided for reject-changes action');
				}
				await this.applyPartialChanges(proposal, decision.changeIndexes, false);
				break;
		}
	}

	private async applyPartialChanges(
		proposal: IEditProposalWithChanges,
		changeIndexes: number[],
		accept: boolean
	): Promise<void> {
		const uri = URI.file(proposal.filePath);
		
		if (accept) {
			// Apply only selected changes
			const newContent = applyChanges(
				proposal.originalContent,
				proposal.changes,
				changeIndexes
			);
			await this.fileService.writeFile(uri, VSBuffer.fromString(newContent));
			
			// Update proposal status
			proposal.status = 'partially-accepted';
			this._onDidChangeProposalStatus.fire(proposal);
			
			this.logDecision(proposal, 'partially-accepted');
			this.appendSystemMessage(
				`Partially applied proposal ${proposal.id} to ${proposal.path} (${changeIndexes.length} changes).`
			);
		} else {
			// Reject only selected changes - keep the rest pending
			const remainingChanges = proposal.changes.filter((_, index) => 
				!changeIndexes.includes(index)
			);
			
			if (remainingChanges.length === 0) {
				// All changes rejected
				await this.rejectEditProposal(proposal.id);
			} else {
				// Some changes still pending
				proposal.changes = remainingChanges;
				this._onDidChangeProposalStatus.fire(proposal);
				this.appendSystemMessage(
					`Rejected ${changeIndexes.length} changes from proposal ${proposal.id}.`
				);
			}
		}
	}

	async acceptAllProposals(): Promise<void> {
		const pending = this.getPendingProposals();
		const results: string[] = [];
		
		for (const proposal of pending) {
			try {
				await this.acceptEditProposal(proposal.id);
				results.push(`✓ ${proposal.path}`);
			} catch (error) {
				results.push(`✗ ${proposal.path}: ${error instanceof Error ? error.message : 'Unknown error'}`);
			}
		}
		
		this.appendSystemMessage(
			`Accepted all proposals:\n${results.join('\n')}`
		);
	}

	async rejectAllProposals(): Promise<void> {
		const pending = this.getPendingProposals();
		const results: string[] = [];
		
		for (const proposal of pending) {
			try {
				await this.rejectEditProposal(proposal.id);
				results.push(`✓ ${proposal.path}`);
			} catch (error) {
				results.push(`✗ ${proposal.path}: ${error instanceof Error ? error.message : 'Unknown error'}`);
			}
		}
		
		this.appendSystemMessage(
			`Rejected all proposals:\n${results.join('\n')}`
		);
	}

	getProposalAuditLog(): Array<{
		id: string;
		path: string;
		action: string;
		timestamp: number;
	}> {
		return [...this.auditLog];
	}

	abortCurrentStream(): void {
		if (this.currentStreamAbortController) {
			this.currentStreamAbortController.abort();
			this.currentStreamAbortController = undefined;
		}
	}

	isCurrentlyStreaming(): boolean {
		return this.currentStreamAbortController !== undefined;
	}
}
